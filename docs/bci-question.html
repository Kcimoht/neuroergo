<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Technologie d’Interface Cerveau-Machine – Questions de Neuro-Ergonomie</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Questions de Neuro-Ergonomie</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Accueil</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./fmri-question.html"> 
<span class="menu-text">Analyse IRMf</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./bci-question.html" aria-current="page"> 
<span class="menu-text">Technologie ICM</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./about.html"> 
<span class="menu-text">À propos</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#technologie-actuelle-et-méthodes" id="toc-technologie-actuelle-et-méthodes" class="nav-link" data-scroll-target="#technologie-actuelle-et-méthodes">Technologie Actuelle et Méthodes</a></li>
  <li><a href="#limitations-techniques-actuelles" id="toc-limitations-techniques-actuelles" class="nav-link" data-scroll-target="#limitations-techniques-actuelles">Limitations Techniques Actuelles</a></li>
  <li><a href="#mise-en-œuvre-et-considérations-pratiques" id="toc-mise-en-œuvre-et-considérations-pratiques" class="nav-link" data-scroll-target="#mise-en-œuvre-et-considérations-pratiques">Mise en Œuvre et Considérations Pratiques</a></li>
  <li><a href="#résultats-de-recherche-actuels" id="toc-résultats-de-recherche-actuels" class="nav-link" data-scroll-target="#résultats-de-recherche-actuels">Résultats de Recherche Actuels</a></li>
  <li><a href="#directions-futures-et-solutions-potentielles" id="toc-directions-futures-et-solutions-potentielles" class="nav-link" data-scroll-target="#directions-futures-et-solutions-potentielles">Directions Futures et Solutions Potentielles</a></li>
  <li><a href="#conclusion" id="toc-conclusion" class="nav-link" data-scroll-target="#conclusion">Conclusion</a></li>
  <li><a href="#références" id="toc-références" class="nav-link" data-scroll-target="#références">Références</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-page-left" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Technologie d’Interface Cerveau-Machine</h1>
<p class="subtitle lead">Quelles sont les limitations actuelles des ICM non invasives pour la communication ?</p>
</div>



<div class="quarto-title-meta column-page-left">

    
  
    
  </div>
  


</header>


<!-- Hidden image to ensure it gets copied to output -->
<p><img src="images/bci-banner.jpg" class="hidden img-fluid" style="display: none;"></p>
<section id="non-invasive-bci-communication" class="level1 unlisted content-block" style="background: linear-gradient(rgba(0, 0, 0, 0.6), rgba(0, 0, 0, 0.6)), url('images/bci-banner.jpg'); background-size: cover; color: white; padding: 4rem 2rem; text-align: center; margin-bottom: 2rem;">
<h1 class="unlisted">Communication par ICM Non Invasive</h1>
<p>Examen des limitations techniques et pratiques de la technologie actuelle</p>
</section>
<section id="introduction" class="level2 content-block">
<h2 class="anchored" data-anchor-id="introduction">Introduction</h2>
<p>La technologie d’Interface Cerveau-Machine (ICM) représente une avancée révolutionnaire dans l’interaction homme-machine, offrant de nouvelles possibilités de communication directe entre le cerveau et les dispositifs externes. Alors que ce domaine continue d’évoluer, une question critique émerge : Quelles sont les limitations actuelles des interfaces cerveau-machine non invasives pour la communication, et comment peuvent-elles être abordées ? Cette question est particulièrement pertinente alors que les chercheurs et les développeurs travaillent à rendre la technologie ICM plus accessible et pratique pour une utilisation quotidienne.</p>
<p>Le développement de systèmes ICM non invasifs efficaces fait face à de nombreux défis, des contraintes techniques aux problèmes d’implémentation pratique. Comprendre ces limitations est crucial pour faire avancer le domaine et développer des solutions plus robustes et conviviales pour les utilisateurs, en particulier ceux ayant des déficiences en matière de communication.</p>
</section>
<section id="technologie-actuelle-et-méthodes" class="level2 content-block">
<h2 class="anchored" data-anchor-id="technologie-actuelle-et-méthodes">Technologie Actuelle et Méthodes</h2>
<p>Le paysage de la technologie ICM non invasive est dominé par plusieurs approches clés, chacune avec ses propres forces et limitations. Les systèmes basés sur l’électroencéphalographie (EEG) restent les plus largement utilisés, offrant un coût relativement faible et une résolution temporelle élevée, tandis que la technologie fNIRS fournit des informations complémentaires sur l’activité cérébrale à travers les réponses hémodynamiques. Ces systèmes reposent sur des approches de traitement du signal de plus en plus sophistiquées et des algorithmes de classification pour interpréter les signaux cérébraux et les convertir en commandes significatives.</p>
<p>Les composants fondamentaux des systèmes ICM modernes incluent le matériel d’acquisition de signaux, les algorithmes de prétraitement, les méthodes d’extraction de caractéristiques et les systèmes de classification. Chaque composant doit fonctionner en harmonie pour atteindre une communication fiable, tout en maintenant la nature non invasive qui rend ces systèmes accessibles à une population plus large.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/bci-components.jpg" class="img-fluid figure-img"></p>
<figcaption>Composants du système ICM montrant les éléments clés des systèmes non invasifs modernes</figcaption>
</figure>
</div>
</section>
<section id="limitations-techniques-actuelles" class="level2 content-block">
<h2 class="anchored" data-anchor-id="limitations-techniques-actuelles">Limitations Techniques Actuelles</h2>
<p>Les ICM non invasives font face à plusieurs limitations techniques importantes qui affectent leur efficacité pour la communication. Le rapport signal-bruit reste un défi persistant, car les méthodes d’enregistrement non invasives doivent détecter les signaux cérébraux à travers plusieurs couches de tissu. La résolution spatiale est limitée par rapport aux méthodes invasives, rendant difficile la localisation et l’isolement précis de l’activité cérébrale pertinente. L’exactitude temporelle et les exigences de formation de l’utilisateur posent également des contraintes importantes sur les performances du système.</p>
<p>Le traitement des signaux ICM présente son propre ensemble de défis, notamment la suppression des artefacts, l’extraction de caractéristiques et les exigences de traitement en temps réel. Ces obstacles techniques doivent être surmontés tout en maintenant la fiabilité du système et le confort de l’utilisateur.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/bci-technical.jpg" class="img-fluid figure-img"></p>
<figcaption>Visualisation des défis techniques montrant les principales limitations de la technologie ICM actuelle</figcaption>
</figure>
</div>
</section>
<section id="mise-en-œuvre-et-considérations-pratiques" class="level2 content-block">
<h2 class="anchored" data-anchor-id="mise-en-œuvre-et-considérations-pratiques">Mise en Œuvre et Considérations Pratiques</h2>
<p>La mise en œuvre pratique des systèmes ICM introduit des défis supplémentaires au-delà des limitations techniques. La fatigue de l’utilisateur est une préoccupation majeure, car maintenir des signaux cérébraux cohérents sur de longues périodes peut être mentalement épuisant. Les interférences environnementales peuvent considérablement affecter la qualité du signal, tandis que les exigences de calibration et la fiabilité du système affectent l’utilisabilité de ces dispositifs dans des contextes réels.</p>
<p>Le traitement du signal reste au cœur de ces défis pratiques. La nécessité d’une suppression robuste des artefacts, d’une extraction efficace de caractéristiques et d’un traitement précis en temps réel doit être équilibrée avec les ressources informatiques disponibles et les contraintes de temps réel des applications de communication.</p>
</section>
<section id="résultats-de-recherche-actuels" class="level2 content-block">
<h2 class="anchored" data-anchor-id="résultats-de-recherche-actuels">Résultats de Recherche Actuels</h2>
<p>La recherche sur la technologie ICM non invasive a révélé plusieurs limitations clés qui affectent les performances du système. Les taux de transfert d’information restent limités, les systèmes actuels atteignant des vitesses de communication relativement modestes par rapport aux méthodes d’entrée traditionnelles. La précision varie considérablement selon les utilisateurs, et les exigences substantielles en matière de formation peuvent rendre ces systèmes difficiles à adopter. La sensibilité environnementale continue de poser des défis pour un fonctionnement fiable en dehors des paramètres de laboratoire.</p>
<p>Ces résultats soulignent la nécessité de poursuivre la recherche et le développement dans des domaines clés tels que les techniques avancées de traitement du signal, l’amélioration des interfaces utilisateur et des algorithmes de classification plus robustes. L’intégration d’approches d’apprentissage automatique montre des promesses pour répondre à certaines de ces limitations.</p>
</section>
<section id="directions-futures-et-solutions-potentielles" class="level2 content-block">
<h2 class="anchored" data-anchor-id="directions-futures-et-solutions-potentielles">Directions Futures et Solutions Potentielles</h2>
<p>L’avenir de la technologie ICM non invasive réside dans la résolution des limitations actuelles grâce à des approches innovantes et des technologies émergentes. Les techniques avancées de traitement du signal et les systèmes ICM hybrides qui combinent plusieurs modalités d’enregistrement montrent des promesses pour améliorer les performances du système. L’amélioration des interfaces utilisateur et l’intégration d’algorithmes d’apprentissage automatique plus sophistiqués peuvent aider à réduire les exigences de formation et à augmenter la fiabilité du système.</p>
<p>Le développement de systèmes plus robustes et conviviaux pourrait considérablement élargir les applications des ICM non invasives, en particulier dans les contextes de communication assistée et de réadaptation.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/bci-future.jpg" class="img-fluid figure-img"></p>
<figcaption>Développements futurs de l’ICM mettant en évidence les solutions et technologies émergentes</figcaption>
</figure>
</div>
</section>
<section id="conclusion" class="level2 content-block">
<h2 class="anchored" data-anchor-id="conclusion">Conclusion</h2>
<p>Bien que la technologie ICM non invasive montre un grand potentiel pour les applications de communication, des limitations importantes doivent encore être surmontées. Les défis techniques dans l’acquisition et le traitement des signaux, combinés aux problèmes d’implémentation pratique, continuent de contraindre l’adoption généralisée de ces systèmes. Cependant, la recherche en cours et les avancées technologiques suggèrent que beaucoup de ces limitations peuvent être résolues grâce à des solutions innovantes et à une conception de système améliorée.</p>
</section>
<section id="références" class="level2 content-block">
<h2 class="anchored" data-anchor-id="références">Références</h2>
<ol type="1">
<li><p>Wilson et al.&nbsp;(2024). “Communication par ICM Non Invasive”</p></li>
<li><p>Lee &amp; Garcia (2023). “Traitement du Signal dans les ICM”</p></li>
<li><p>Thompson et al.&nbsp;(2024). “Expérience Utilisateur dans les Systèmes ICM”</p></li>
</ol>
</section>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Neuro-Ergonomie - Hiver 2025</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>